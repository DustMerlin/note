# bug#189247

## 问题分析：

    从现象很容易想象到，这又是kernel的处理仅针对了初始化的操作
    而在其他情况更新的源的时候，并未有额外的处理

    处理显示kernel 这块的逻辑，再 _reset_repo_store() 这个函数
    此前有所了解，但是找到这块，还是不得不粗略的看一遍代码

    测试现象： 在取消勾选和勾选 appstream 的时候，源均被更新，且 appstream 被去除和替换了

    当前分析结论：appsteam 源的更新是正常的，仅需在appstream 处理完成后再出发处理kernel 即可

    不难想象，但此时又很容易循环调用，导致死循环，但具体情况得测试了才能确定，目前还不能肯定
    以上情况，是最近每次改动内核所不得不面对的问题，每次尽量在规避，但还是会造成非常多的困扰
    也暂时没有更好的办法，以目前所要求的内容，去解耦合的实现，需求和代码设计层次上的矛盾
    ！ 暂时理论上应该无解

    此时可以想象，source 源选择的逻辑，是在选择后按照列表的规则，去重新加载所有的源
    而此时的矛盾是，可能是按当前列表里的源存在与否剔除相应的源,比如都选则不做处理，如果不勾选则剔除
    是符合现象，且合理的猜测，此处需要查看代码验证！！！

    _reset_repo_store() 对kernel的处理，存在破坏原有逻辑的问题，按上述逻辑，
    被剔除的kernel其实脱离了此部分代码的控制（数据被移除），且加载源的部分，并无从得知该情况，
    仅仅负责加载所有的源，导致出现上述的情况，以上猜想目前逻辑自洽

    单独但又些许关联影响的问题(一)：原先以数量判断源，导致如果appsteam不存在，源的数量不足，依旧不会出发kernel更新的操作
    现象是，/tmp/dnf.cache 中有两个kernel，但在此时如果在软件选择中选择kernel,并不会导致kernel切换

    appstream 也就是当前bug的问题和问题（一），不是同一个问题的推断依据
    此处可能都不是走的同一个流程
    appsteam 被取消勾选之后，/tmp/dnf.cache中只有两个kernel，此现象并不能看出什么情况来
    但是重新勾选appseam，/tmp/dnf.cache 有三个源，此情况是可以触发源过多而剔除kernel的操作的，但是并没有触发，所以该执行过程不同

    侵入式的现象验证，直接删除/tmp/dnf.cache 中的kernel观察现象：
        情况一：如果删除kernel后依旧出现，则证明所有源被重新加载，在重新加载过程中，appsteam 被处理了（保留或是删除，根据勾选情况）
        情况二：如果删除kernel后，kernel源不再出现，则证明此过程，没有所有源的重新加载，仅对appsteam，也即仅对列表中存在的appsteam 做处理

    但以上的思考是多余的，appsteam 被去除勾选之后，kernel 均被加载，且没被处理，该情况即可验证当前的所有猜想

    经过验证，猜想一是正确的，且dnf.cache下的文件被全部更新，即所有源被重新加载了
    
## 修改思路：

    找到appsteam更新后，更新源操作的部分，类似的像appsteam把除了当前kernel 的源剔除了
    但是如何确定，也即如何获取当前的kernel 好像也是问题

    或者通知soft_selection 的spokes 去 处理kernel 更合理

    暂时按以上两种思路验证
